import 'dart:async';
import 'dart:io';

import 'package:build/build.dart';
import 'package:pigeon/pigeon.dart';
import 'package:pigeon_build_config/pigeon_build_config.dart';
import 'package:pigeon_build_core/pigeon_build_core.dart';
import 'package:scratch_space/scratch_space.dart';
import 'package:glob/glob.dart';

import 'pigeon_scratch_space.dart';

class PigeonBuilder extends Builder {
  static const String _pubspecFileName = 'pubspec.yaml';

  late final _scratchSpace = createScratchSpace();
  late final _handler = createHandler();
  late final _pigeonConfig = getPigeonConfig();

  late final _scratchSpaceResource = Resource(
    () => _scratchSpace,
    beforeExit: () => _scratchSpace.delete(),
  );

  List<String>? _trackedInputs;
  Set<String> _untrackedOutputsToDelete = {};

  @override
  FutureOr<void> build(BuildStep buildStep) async {
    final space = await buildStep.fetchResource(_scratchSpaceResource);

    await buildStep.canRead(buildStep.inputId);

    if (isMainBuildStep(buildStep)) {
      var config = _pigeonConfig;
      if (config == null) return;

      var pigeonRoot = config.mainInput?.input;
      if (config.inputsInferred && pigeonRoot != null) {
        await buildAllUntrackedAssets(buildStep, space, pigeonRoot);
      }
    } else {
      await buildAsset(buildStep, space, assetIsTracked: true);
    }
  }

  /// Clears untracked assets and rebuilds them according to the assets found in the
  /// main input directory.
  /// 
  /// This method was added to support the `inputs_inferred` option. In order to infer inputs,
  /// we must scan all files in the main input directory. However, since many of these files
  /// are likely already tracked by `build_runner` (they were returned in [buildExtensions]),
  /// we can skip over them. The remaining "untracked" assets are the rest of the inferred inputs
  /// that need to be built.
  /// 
  /// There is one problem however. Because `build_runner` doesn't know about these untracked assets,
  /// we cannot use [ScratchSpace.copyOutput] to write them like normal outputs.
  /// Because of this, we must manually write the output files instead. This means we must
  /// manually make some guarantees that `build_runner` normally provides:
  /// 
  /// 1. generated files must not overwrite existing files
  /// 2. generated files must be automatically cleaned up if their source is removed
  /// 
  /// To accomplish the first, the '.pigeon.xxx' extension is used. By convention, '.pigeon'
  /// indicates a file generated by [Pigeon], so we can assume we aren't overwriting important files.
  /// 
  /// To accomplish the second, we can simply delete all untracked output assets
  /// from the last build step. While this leads to a less granular build process
  /// (all "untracked" pigeon inputs are regenerated every time, even if they didn't change),
  /// this should be okay since it is unlikely a large number of new pigeon inputs
  /// will be created in a single build session.
  FutureOr<void> buildAllUntrackedAssets(BuildStep buildStep, ScratchSpace space, String pigeonRoot) async {
    final _trackedInputs = this._trackedInputs ?? [];
    
    for (var output in _untrackedOutputsToDelete) {
      var file = File(output);
      if (await file.exists()) {
        try {
          await file.delete();
        } catch (error) {
          log.warning('Failed to delete $output from last build step');
        }
      }
    }
    _untrackedOutputsToDelete = {};

    pigeonRoot = pigeonRoot.replaceAll(RegExp(r'/+$'), '');
    var inputsGlob = Glob("$pigeonRoot/**.dart", recursive: true);

    var newInputAssets = await buildStep.findAssets(inputsGlob)
        .where((assetId) {
          var isUntracked = !_trackedInputs.contains(assetId.path);
          return isUntracked;
        })
        .toList();
    
    for (var assetId in newInputAssets) {
      await buildAsset(buildStep, space, inputAssetId: assetId, assetIsTracked: false);
    }
  }

  /// Builds a single pigeon input by writing to its outputs. The input is given by [inputAssetId],
  /// which defaults to using the asset associated with the [buildStep].
  /// 
  /// If the given asset is managed by `build_runner`, then [assetIsTracked] should be `true`.
  /// Managed assets are coped from [ScratchSpace]s and deleted automatically by `build_runner`
  /// between build steps. Alternatively, if the given asset was generated dynamically
  /// instead (not included in [buildExtensions]), then [assetIsTracked] should be `false`.
  /// This indicates the asset should be manually deleted later on the next build step.
  FutureOr<void> buildAsset(BuildStep buildStep, ScratchSpace space, {AssetId? inputAssetId, required bool assetIsTracked}) async {
    inputAssetId ??= buildStep.inputId;
    var package = inputAssetId.package;

    var config = _pigeonConfig;
    if (config == null) return;

    var handlerResult = _handler.handleInput(config, inputAssetId.path);
    var resultOptions = handlerResult.options;
    if (resultOptions == null) return;
    
    await space.ensureAssets(
      [
        AssetId(package, _pubspecFileName),
        inputAssetId,
      ],
      buildStep,
    );
    
    final pigeonOptions = assetIsTracked
        ? getPigeonOptionsForScratchSpace(
          resultOptions,
          buildStep.allowedOutputs,
          space,
        )
        : resultOptions;

    final allOutputs = pigeonOptions.getAllOutputs();

    for (var output in allOutputs) {
      final file = File(output);

      if (!await file.parent.exists()) {
        await file.parent.create(recursive: true);
      }
    }

    await Pigeon.runWithOptions(pigeonOptions);

    if (assetIsTracked) {
      // tracked outputs are written to scratch space;
      // the result must be copied outside the scratch space
      for (var outAssetId in buildStep.allowedOutputs) {
        final scratchFile = space.fileFor(outAssetId);

        if (await scratchFile.exists()) {
          await space.copyOutput(outAssetId, buildStep);
        }
      }
    } else {
      // untracked outputs need to be remembered so we can delete them on rebuild
      _untrackedOutputsToDelete.addAll(allOutputs);
    }
  }

  bool isMainBuildStep(BuildStep buildStep) {
    return buildStep.inputId.path == 'pubspec.yaml';
  }

  @override
  Map<String, List<String>> get buildExtensions {
    final result = <String, List<String>>{
      'pubspec.yaml': ['.pigeon.yaml'], // .pigeon.yaml is a fake output
    };

    if (_pigeonConfig == null) {
      return result;
    }

    final allInputs = _handler.getAllInputs(_pigeonConfig!);
    _trackedInputs ??= allInputs;

    for (var inputPath in allInputs) {
      final handlerResult = _handler.handleInput(_pigeonConfig!, inputPath);

      if (handlerResult.options == null) {
        continue;
      }

      result[inputPath] = handlerResult.options!.getAllOutputs();
    }

    return result;
  }

  PigeonBuildHandler createHandler() => PigeonBuildHandler();

  ScratchSpace createScratchSpace() => PigeonScratchSpace();

  PigeonOptions getPigeonOptionsForScratchSpace(
    PigeonOptions options,
    Iterable<AssetId> allowedOutputs,
    ScratchSpace space,
  ) {
    final newOptions = PigeonOptions(
      input: options.input,
      dartOut: pathToScratchSpacePath(options.dartOut, allowedOutputs, space),
      dartTestOut:
          pathToScratchSpacePath(options.dartTestOut, allowedOutputs, space),
      astOut: pathToScratchSpacePath(options.astOut, allowedOutputs, space),
      javaOut: pathToScratchSpacePath(options.javaOut, allowedOutputs, space),
      kotlinOut:
          pathToScratchSpacePath(options.kotlinOut, allowedOutputs, space),
      objcHeaderOut:
          pathToScratchSpacePath(options.objcHeaderOut, allowedOutputs, space),
      objcSourceOut:
          pathToScratchSpacePath(options.objcSourceOut, allowedOutputs, space),
      swiftOut: pathToScratchSpacePath(options.swiftOut, allowedOutputs, space),
      cppHeaderOut:
          pathToScratchSpacePath(options.cppHeaderOut, allowedOutputs, space),
      cppSourceOut:
          pathToScratchSpacePath(options.cppSourceOut, allowedOutputs, space),
    );

    return options.merge(newOptions);
  }

  String? pathToScratchSpacePath(
      String? path, Iterable<AssetId> allowedOutputs, ScratchSpace space) {
    if (path == null) {
      return null;
    }

    final assetId = allowedOutputs.firstWhere((a) => a.path == path);

    return space.fileFor(assetId).path;
  }

  PigeonBuildConfig? getPigeonConfig() {
    final config = PigeonBuildPubspecParser.parsePubspecFileSync(
      File("pubspec.yaml"),
    );

    if (config != null) {
      PigeonBuildConfigValidator.validateConfig(config);
    }

    return config;
  }
}
